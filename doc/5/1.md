# Introduction to Rendering

## The Big Picture

Вы создали данные модели с помощью Blender и готовы визуализировать свои модели в сцене с помощью WebGL. Теперь начинается самое интересное!

Прежде чем мы начнем, давайте обсудим природу WebGL. WebGL - это API (интерфейс прикладного программиста) для графического процессора (графического процессора). Графический процессор - это аппаратное устройство, оптимизированное для рендеринга 3D-графики в реальном времени. Вы будете писать шейдерные программы, которые компилируются в аппаратное обеспечение и работают с молниеносной скоростью. API WebGL не оптимизирован для программистов; он оптимизирован для быстрого аппаратного рендеринга. WebGL буквально «щелкает переключателями» на оборудовании для подключения схем. Не ждите команд высокого уровня. WebGL API - это очень низкоуровневый набор команд, управляющих функциональностью аппаратного уровня.

Как мы уже обсуждали, есть этапы предварительной обработки, которые выполняются только один раз для настройки WebGL и вашей сцены. Затем есть шаги по визуализации моделей в сцене. Эти шаги повторяются каждый раз, когда вы перерисовываете сцену.


## Pre-processing: WebGL Setup

На высоком уровне абстракции этапы предварительной обработки:

* Получите элемент холста HTML, в который вы будете выполнять рендеринг.
* Получите контекст WebGL для элемента холста, который обычно называется gl.
* Установите желаемое состояние для контекста gl.
* Скомпилируйте и свяжите свой вершинный шейдер и программы фрагментного шейдера с программой рендеринга. (Можно создать более одной программы рендеринга.)
* Получите ссылки на переменные в вашей программе рендеринга, чтобы вы могли установить их значения во время рендеринга.
* Для каждой модели в вашей сцене:
* Преобразуйте данные вашей модели OBJ в соответствующие массивы для рендеринга.
* Создайте буферный объект в памяти графического процессора.
* Скопируйте данные вашей модели в буферный объект.

Мы зафиксируем детали этих шагов в нескольких классах JavaScript, потому что:

* Класс JavaScript инкапсулирует функциональность в одном месте, которое может быть легко выполнено один раз.
* Класс JavaScript может скрыть детали функциональности всего за несколько вызовов функций.
* Класс JavaScript позволяет легко повторно использовать функциональные возможности.


## A Brief Introduction to Shader Programs

Прежде чем мы обсудим конкретные шаги для рендеринга моделей, нам нужно обсудить некоторые основные идеи, лежащие в основе шейдерных программ. В графическом конвейере есть два этапа, которые вы должны запрограммировать самостоятельно. Вы пишете программы на GLSL (GL Shader Language), компилируете их в машинные инструкции, связываете их в «программу», загружаете программу в графический процессор, а затем активируете программу при визуализации сцены. Результатом рендеринга является 2D-массив пикселей. Многие фрагменты данных хранятся и обрабатываются для каждого пикселя. Группа данных, связанных с одним пикселем, называется фрагментом. Когда вы видите слово «фрагмент», подумайте «пиксель и связанные с ним данные рендеринга».

Учтите, что для визуализации треугольника, отображаемого в изображение, может потребоваться 100 или даже 1000 пикселей, потому что зритель находится очень близко к треугольнику. Если зритель находится далеко от треугольника, треугольник может отображаться с одним или двумя пикселями. Количество фрагментов, которые создаются для визуализации отдельного треугольника, будет постоянно меняться в зависимости от расстояния между зрителем и треугольником.

Две ваши шейдерные программы имеют очень ограниченный набор функций:

* Вершинный шейдер преобразует каждую вершину модели в ее правильное положение для текущей сцены.
* Фрагментный шейдер назначает цвет каждому фрагменту (пикселю), который составляет точку, линию или треугольник.

Это звучит достаточно просто, а может быть и очень просто. Вы можете создавать программы шейдеров, которые выполняют свои требуемые функции в одной строке кода. Или вы можете делать удивительные манипуляции, используя очень сложные алгоритмы. Прелесть шейдерных программ в том, что вы полностью контролируете графический процесс.

Обратите внимание, что вершинные и фрагментные шейдеры имеют общие переменные. Вершинный шейдер часто устанавливает значения для использования фрагментного шейдера. Это станет яснее, когда мы подробно изучим шейдерные программы.

Шейдерные программы используют три типа данных. Данные, одинаковые для всей модели, данные, которые изменяются для каждой вершины, и данные, которые изменяются для каждого фрагмента внутри точки, линии или треугольника. 

Эти три типа данных:

* `uniform` Значение данных, одинаковое для выполнения графического конвейера. Например, если вы собираетесь присвоить один и тот же цвет каждой обработанной вершине, тогда этот цвет может быть универсальной переменной. Когда вы думаете об однородном значении, думайте о фиксированном, неизменном, неизменном значении.
* `attribute` Значение данных, которое изменяется для каждой вершины, когда графический конвейер обрабатывает вершины. Типичное значение атрибута - это положение вершины (x, y, z). Когда вы думаете о значении атрибута, всегда включайте вершину в термин, как в атрибуте вершины.
* `varying` Значение данных, которое изменяется для каждого фрагмента во время выполнения графического конвейера. Изменяющаяся переменная позволяет каждому пикселю, составляющему точку, линию или треугольник, назначать другой цвет.


## Rendering Steps

Каждый раз, когда вы визуализируете свою сцену, ваша программа JavaScript должна выполнять следующие шаги:

1. Очистите буфер цвета, который удерживает ваш рендеринг до цвета фона.
1. Если вы удаляете скрытую поверхность, очистите буфер глубины.
1. Выберите свою шейдерную программу.
1. Для каждой модели в вашей сцене:
	1. Передайте значения ваших `uniform` переменных в вашу программу шейдера.
	1. Присоедините каждую переменную `attribute` к соответствующему объекту буфера.
	1. Вызовите функцию WebGL `gl.drawArrays()`.

Следующая диаграмма поможет вам наглядно представить эти шаги.


## Rendering Speed Considerations

Весь рендеринг выполняется в контексте. То же самое можно сказать обо всем, что вы делаете как личность. Вы можете заниматься в библиотеке или заниматься во время футбольного матча. Контекст, в котором вы находитесь, влияет на ваше обучение! И люди постоянно меняют контекст, сознательно или неосознанно. Если вы глубоко о чем-то думаете, вам может потребоваться несколько секунд, чтобы понять, что с вами кто-то разговаривает. Любое переключение контекста требует времени. Если вы постоянно переключаете контекст, вы не будете очень продуктивны.

Все современные компьютеры постоянно переключаются между запущенными процессами. Графический процессор ничем не отличается. Вы всегда выполняете рендеринг в контексте. Чем реже вы переключаете контексты, тем быстрее выполняется рендеринг. Поэтому, когда вы настраиваете процесс рендеринга, одной из ваших основных целей должно быть минимизация количества переключений контекста. Все следующие действия вызывают переключение контекста графическим процессором:

* Выбор шейдерной программы.
* Установка значения `uniform` переменной в программе шейдера.
* Присоединение переменной `attribute` к объекту буфера.
* Любое действие, изменяющее состояние объекта JavaScript gl.

Любая связь между вашей программой JavaScript и графическим процессором замедляет рендеринг. Чтобы получить максимальную скорость рендеринга, вам необходимо свести к минимуму вызовы функций JavaScript в API WebGL. Например, у вас может быть отдельный буферный объект для каждой модели или вы можете хранить несколько моделей в одном буферном объекте. Количество возможных конфигураций практически безгранично. Вам придется постоянно искать компромисс между желанием быстрого рендеринга, объемом памяти, который вы используете для своих графических данных, и сложностью вашего кода.

Скажем еще раз: любое взаимодействие между вашей программой JavaScript и графическим процессором замедляет рендеринг. В идеальном случае вы скопируете все данные своей модели в графический процессор только один раз. Затем, когда вы выполняете рендеринг, у графического процессора уже есть большая часть необходимых данных. В случаях, когда ваш код JavaScript должен манипулировать данными модели перед каждым рендерингом, перенос данных из ОЗУ в память графического процессора будет серьезным ограничением по времени. В таких случаях вы захотите разделить данные вашей модели на различные типы данных и передавать только те данные, которые меняются. Например, если данные вашей модели включают вершины, цвета и векторы нормалей, а ваша программа JavaScript управляет только данными цвета, тогда вы поместите данные вектора вершин и нормалей в объект буфера графического процессора, а данные цвета - в отдельный буферный объект. Когда вы визуализируете модель, ваш код JavaScript изменяет значения цвета, копирует их в буферный объект графического процессора, а затем вызывает gl.drawArrays (). Сведение к минимуму объема данных, копируемых в графический процессор при каждом рендеринге, ускорит рендеринг.

В общем, вы должны сначала заставить вашу графику правильно отображаться, а затем оптимизировать ее для более быстрой визуализации. Вы будете удивлены тем, насколько быстрым является графический процессор, и во многих ситуациях оптимизация не требуется. Для этих руководств мы напишем код JavaScript и организуем данные модели таким образом, чтобы подчеркнуть ясность, а не оптимизацию рендеринга.

## Code and Data Dependencies

Программы WebGL визуализируют модели с использованием трех основных компонентов:

* Программа шейдера, которая манипулирует местоположением вершин и назначает цвета пикселям. Шейдерные программы выполняются на графическом процессоре.
* Буферы объектов вершин, которые хранят данные атрибутов вершин модели на GPU.
* Код JavaScript, который устанавливает и запускает рендеринг. Код JavaScript выполняется центральным процессором.

Эти три компонента взаимосвязаны до такой степени, что простое изменение одного компонента обычно требует изменения всех компонентов. Это прискорбно, потому что очень затрудняет инкрементную разработку кода. В любом случае, если вы изменяете какую-либо часть программы шейдера, буферный объект или функцию рендеринга JavaScript, убедитесь, что другие компоненты совместимы с вашими изменениями.


