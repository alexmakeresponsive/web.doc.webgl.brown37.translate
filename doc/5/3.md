# A Primer on Buffer Objects

Буферный объект - это непрерывный блок памяти в графическом процессоре, к которому могут очень быстро получить доступ шейдерные программы, выполняющиеся на графическом процессоре. Объекты буфера хранят данные, которые необходимы шейдерным программам для рендеринга. Содержимое объекта буфера всегда представляет собой одномерный массив. Для наших целей мы будем рассматривать объект-буфер как всегда однородный, то есть каждое значение будет иметь один и тот же тип данных. (Вы можете смешивать типы данных с некоторым сложным кодом JavaScript, но давайте будем простыми.)

Объекты буфера предоставляют данные для переменных атрибутов в программах вершинных шейдеров. Помните, что WebGL - это ограниченное подмножество OpenGL, а WebGL допускает только атрибутные переменные типа float, vec2, vec3, vec4, mat2, mat3 и mat4. Все это значения с плавающей запятой. Следовательно, все создаваемые вами буферные объекты будут массивами значений с плавающей запятой.

JavaScript не является строго типизированным языком и не делает различий между разными типами чисел. В большинстве языков программирования есть шорты, целые числа, числа с плавающей запятой и двойные. В JavaScript есть только один тип данных для числовых значений: число. JavaScript был изменен для работы со значениями двоичных данных путем добавления объектов «типизированного массива». Для WebGL все ваши буферные объекты будут содержать массивы **`Float32Array`**.

	// Floating point arrays.
	var f32 = new Float32Array(size); 
	// Fractional values with 7 digits of accuracy

Есть два способа поместить данные в «типизированный массив»:

* Включите обычный массив чисел JavaScript в качестве параметра конструктора.
* Создайте массив определенного размера, а затем установите для отдельных элементов определенные значения.

Эти два варианта показаны в следующем коде:
	
	// Create an array containing 6 floats. Notice the brackets around the array data.
	var my_array = new Float32Array( [1.0, 2.0, 3.0, -1.0, -2.0, -3.0] );
	
	// Create an array to hold 4 floating point numbers.
	var an_array = new Float32Array(4);
	an_array[0] = 12.0;
	an_array[1] =  5.0;
	an_array[2] = 37.0;
	an_array[3] = 18.3;


## Creating and Initializing Buffer Objects

Обратите внимание, что буферные объекты находятся в графическом процессоре, но они создаются, управляются и удаляются с помощью API WebGL из кода JavaScript. Вот типичная последовательность команд для создания буферного объекта и заполнения его данными.
	
	function createAndFillBufferObject(gl, data) {
	  var buffer_id;
	
	  // Create a buffer object
	  buffer_id = gl.createBuffer();
	  if (!buffer_id) {
	    out.displayError('Failed to create the buffer object for ' + model_name);
	    return null;
	  }
	
	  // Make the buffer object the active buffer.
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer_id);
	
	  // Upload the data for this buffer object to the GPU.
	  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	
	  return buffer_id;
	}

Обратите внимание на следующий код:

* Создание объектного буфера не более чем резервирует новый идентификатор для нового буфера.
* Обычно у вас много объектных буферов, и только один из них является «активным буфером». Когда вы отдаете команды буферным объектам, вы всегда управляете «активным буфером». Функция **`bindBuffer`** просто меняет «активный буфер» на конкретный буфер, используя **`buffer_id`**.
* Функция **`bufferData`** копирует данные из вашей программы JavaScript в буферный объект графического процессора. Если в объекте буфера уже были данные, его текущее содержимое удаляется и добавляются новые данные.
* Основная ошибка, которую вы получите при копировании данных в графический процессор, - это `OUT_OF_MEMORY`. Приведенный выше код должен проверять наличие ошибок gl, вызывая `gl.getError()`, но мы побеспокоимся об обнаружении ошибок позже.


## Shaders, Buffers, and the Graphics Pipeline

Шейдерные программы иногда трудно «осмыслить», потому что взаимосвязь между графическим конвейером и шейдерной программой неочевидна и иногда никогда не объясняется. Давайте попробуем написать псевдокод, описывающий, как графический конвейер выполняет рендеринг.

Каждый раз, когда ваша программа JavaScript вызывает gl.drawArrays (mode, start, count), число вершин «count» отправляется через графический конвейер. Ваша программа вершинного шейдера вызывается один раз для каждой вершины в массиве вершин, который хранится в объекте буфера. Внутри графического конвейера, скрытый от вас, есть алгоритм, который делает это:

	for (j = start; j < count; j += 1) {
	  call vertex_shader(vertex_buffer[j]);
	}

Вершинным и фрагментным шейдерам нужно больше, чем просто данные о местоположении, если они собираются создавать сложные графические изображения. Такая информация включает цвет, вектор нормали, координаты текстуры и т. Д. Поскольку графический конвейер оптимизирован по скорости, другие данные должны быть организованы в массивы в том же порядке, что и данные вершин. Если у каждой вершины есть дополнительные атрибуты, приведенный выше псевдокод становится примерно таким:

for (j = start; j < count; j += 1) {
  call vertex_shader(vertex_buffer[j], color_buffer[j], normal_vector_buffer[j], ...);
}

Это важный базовый принцип рендеринга WebGL. Все данные должны быть организованы «по вершинам» из-за способа работы конвейера. Это означает, что в некоторых случаях ваши данные должны дублироваться в массивах несколько раз, чтобы «совпадать» с данными вершин. Это может быть очень неэффективно для использования памяти, но делает рендеринг очень быстрым. Чтобы проиллюстрировать этот принцип, предположим, что вы хотите визуализировать треугольник с использованием определенного цвета. Вы должны создать массив, в котором хранится цвет каждой отдельной вершины, даже если все три вершины имеют одинаковый цвет. В приведенном ниже коде показан массив из 9 значений, представляющий 3 вершины. Если цвет вершин поступает из массива в буферном объекте, цвет должен быть сохранен в три раза, чтобы «совпадать» с данными вершины. В приведенном ниже примере красный цвет сохраняется три раза.

	var triangle_vertices = [0,0,0, 1,6,2, 3,4,1];
	var triangle_color    = [1,0,0, 1,0,0, 1,0,0]

