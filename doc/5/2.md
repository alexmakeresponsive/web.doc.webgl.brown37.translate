# A Primer on Shaders

## The Big Picture

В разделе 12 этих руководств подробно рассматривается язык шейдеров GL (GLSL). Но для начала вам нужно понимать «общую картину» и несколько основных языковых деталей.

Шейдерные программы работают с отдельными вершинами и отдельными фрагментами, по одной вершине и по одному фрагменту за раз. У вас нет контроля над вызовом шейдерных программ. Они автоматически вызываются графическим конвейером.

Прежде чем шейдер можно будет использовать, вы должны получить данные модели в буфер объекта вершины графического процессора, который представляет собой просто непрерывный блок памяти, к которому графический процессор может получить прямой доступ без использования системной шины. Буфер объекта вершины должен быть организован как массив, где к данным можно получить доступ с помощью индекса для получения последовательных значений из массива. В идеале данные модели копируются в буфер объекта вершины только один раз на этапе предварительной обработки. Вы создадите множество буферов вершинных объектов. Каждый из них будет хранить данные для определенного значения атрибута массива вершин или, возможно, всех атрибутов вершин для всей модели.

Чтобы отобразить модель, ваш код Javascript сообщит программе шейдера, какой буфер объекта вершины использовать в качестве источника данных. Когда ваша программа JavaScript вызывает `gl.drawArrays(mode, first, count)`, графический конвейер будет извлекать вершины, начиная с вершины массива `[first]`, и отображать вершины count из массива. Если вы вызовете функцию `gl.drawArrays(mode, 5, 10)`, она отобразит вершины в ячейках массива с **`[5]`** по **`[14]`**. (Индексы массивов всегда имеют нулевой индекс.)

Параметр `mode` функции gl.drawArrays будет определять, как вершины используются для рендеринга элементов. Возможные режимы рисования показаны на схеме.

![](../../asset/drawing_modes.png)

Вершинный шейдер будет выполнять идентичные вычисления для каждой вершины, которую он извлекает из буфера вершинного объекта. Каждое выполнение вершинного шейдера - это уникальный экземпляр во время выполнения. Вы не можете установить переменную за одно выполнение и ожидать, что переменная будет иметь это значение в следующем экземпляре времени выполнения. Это сильно отличается от вашего предыдущего опыта работы с языком программирования.

Задача вершинного шейдера - назначить специальной переменной gl_Position вектор из 4 значений (x, y, z, w). Это значение передается в графическом конвейере на следующий этап конвейера. Вау, это странно! Это может не иметь большого смысла, пока вы не увидите более конкретные примеры. Но продолжайте читать!

Выходные данные, gl_Position, вершинного шейдера передаются на следующий этап графического конвейера - этап «Преобразование видового экрана». Это преобразует положение вершины в положение пикселя на визуализированном изображении. Это местоположение пикселя (и связанные с ним данные визуализации) передаются на следующий этап - «Растеризатор». На этом этапе определяются пиксели, которые покрывает объект. Это зависит от того, является ли вершина частью точки, линии или треугольника. «Растеризатор» составляет список всех пикселей, которые необходимо раскрасить для представления объекта, а затем передает каждый пиксель и связанные с ним данные визуализации в ваш фрагментный шейдер. Помните, что пиксель и связанные с ним данные рендеринга называются фрагментом.

Задача фрагментного шейдера - присвоить значение цвета RGBA специальной переменной gl_FragColor. Этот цвет передается на этап «Компостирование» графического конвейера, а значение цвета используется для обновления создаваемого растрового изображения.

Подведем итоги! Ваш вершинный шейдер позиционирует вершины модели. Затем ваш фрагментный шейдер назначит цвет всем пикселям, покрытым объектом, определенным вершинами. Это так просто или так сложно, в зависимости от вашей точки зрения. Пожалуйста, сделайте паузу и изучите схему графического конвейера.

## Fragments

Просто чтобы прояснить ситуацию:

* Вершинный шейдер должен устанавливать значение одной переменной: gl_Position
* Фрагментный шейдер должен устанавливать значение одной переменной: gl_FragColor.

Но то, что проходит между этапами конвейера, - это не только эти значения. Вершинные шейдеры и фрагментные шейдеры разделяют переменные на вершинной основе. Таким образом, вершинный шейдер обычно связывает цвет и другую информацию со значением gl_Position. Эта информация передается на следующем этапе графического конвейера. При разработке шейдерных программ мы постараемся прояснить, как данные передаются по конвейеру.


## Shader Language Variables

GLSL - это строго типизированный язык. Все переменные должны быть объявлены до их использования. Объявления переменных состоят из трех частей: «Квалификатор хранилища», «тип данных» и «имя переменной».

«Квалификаторы хранилища» определяют, как значение изменяется во время вызова gl.drawArrays (),

* `uniform` Значение данных, одинаковое для всего выполнения gl.drawArrays ().
* `attribute` Значение данных, которое изменяется для каждой вершины выполнения gl.drawArrays ().
* `varying` Значение данных, которое изменяется для каждого фрагмента выполнения gl.drawArrays ().

«Тип данных» определяет тип данных, которые хранятся в переменной. Есть много типов данных. А пока ограничимся следующим:

* `int` Целое число со знаком.
* `float` Дробное число; приблизительно 7 знаков точности.
* `vec3` Вектор из трех чисел с плавающей запятой.
* `vec4` Вектор из 4 чисел с плавающей запятой.
* `mat4` Матрица 4x4 чисел с плавающей запятой. (16 значений)

Имена переменных начинаются с буквы или символа подчеркивания и содержат только буквы, цифры и символ подчеркивания. Имена переменных чувствительны к регистру. Распространенным соглашением является начало универсальных переменных с `u_`, переменных атрибутов с `a_` и переменных переменных с `v_`.

Выполнение программы шейдера всегда начинается с функции main (). Вы можете реализовать столько подфункций, сколько потребуется вашему шейдеру.

Переменные, объявленные вне функции main (), имеют глобальную область видимости. Если переменная с тем же именем объявлена ​​глобальной как в вершинном шейдере, так и во фрагментном шейдере, это одна и та же переменная. Любые переменные, объявленные внутри функции, имеют локальную область видимости и локальное время жизни.

Обратите внимание, что JavaScript и GLSL очень разные языки, и вам придется разделять их синтаксис и семантику.

Все эти вопросы станут более понятными, если мы рассмотрим примеры. Если в примерах шейдеров есть лишнее словоблудие, которое мы еще не обсуждали, просто игнорируйте его пока. «Дополнительные вещи» будут объяснены в Разделе 12.


## The Simplest Shaders Possible

Ниже представлены, пожалуй, самые простые и функциональные программы шейдеров. Программы вершинного и фрагментного шейдеров должны храниться отдельно, потому что они компилируются отдельно, а затем связываются в единую программу шейдера. Синтаксис наиболее близко соответствует языку программирования C для определений функций, операторов присваивания, операторов if и циклов. Что сильно отличается от языка C, так это встроенные типы данных, преобразование значений в разные типы данных и встроенные векторные и матричные операторы.

Ниже представлен очень простой вершинный шейдер, который преобразует каждую вершину с помощью матрицы преобразования 4x4.

	// Vertex Shader
	uniform   mat4 u_Transform;
	uniform   vec4 u_Color;
	
	attribute vec3 a_Vertex;
	
	void main() {
	  // Transform the location of the vertex
	  gl_Position = u_Transform * vec4(a_Vertex, 1.0);
	}
	
Ниже представлен очень простой фрагментный шейдер, который устанавливает одинаковый цвет для каждого пикселя.
	
	// Fragment shader
	uniform vec4 u_Color;
	
	void main() {
	  gl_FragColor = u_Color;
	}





